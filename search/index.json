[{"content":"1、模式 1、模式类型： 创建型 2、定义： 建造者模式（Builder Pattern）:\n使用多个简单的对象一步一步构建成一个复杂的对象。这种类型的设计模式属于创建型模式，它提供了一种创建对象的最佳方式。\n3、原理类图 4、工作原理 2、实例： 3、注意事项 优点： 分离构建过程和表示，使得构建过程更加灵活，可以构建不同的表示。 可以更好地控制构建过程，隐藏具体构建细节。 代码复用性高，可以在不同的构建过程中重复使用相同的建造者。\n缺点：\n如果产品的属性较少，建造者模式可能会导致代码冗余。 建造者模式增加了系统的类和对象数量。\n4、应用场景 参考资料 设计模式资料 常用结构性模型\n设计模式-视频讲解\n设计模式-原则\n","date":"2024-01-10T00:00:00Z","permalink":"https://justkids.top/p/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%BB%BA%E9%80%A0%E8%80%85%E6%A8%A1%E5%BC%8F/","title":"设计模式-建造者模式"},{"content":"1、外观模式也叫门面模式 1、模式类型： 结构型 2、定义： 外观模式（Facade），也叫“过程模式 外观模式为子系统中的一组接口提供一个一致的界面，此模式定义了一个高层接口，这个接口使得这一子系统更加 容易使用 外观模式通过定义一个一致的接口，用以屏蔽内部子系统的细节，使得调用端 只需跟这个接口发生调用，而无需关心这个子系统的内部细节 3、原理类图 3.1 uml 图 3.2 原理说明 0 1 2 3 1) 外观类(Facade): 为调用端提供统一的调用接口, 外观类知道哪些子系统负责处理请求,从而将调用端的请求代理给适当 子系统对象 2) 调用者(Client): 外观接口的调用者 3) 子系统的集合：指模块或者子系统，处理Facade 对象指派的任务，他是功能的实际提供者 2、代码实例： 0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 // 子系统接口 public interface SubsystemA { void operationA(); } public interface SubsystemB { void operationB(); } public interface SubsystemC { void operationC(); } // 具体子系统实现 public class ConcreteSubsystemA implements SubsystemA { @Override public void operationA() { System.out.println(\u0026#34;SubsystemA operation A\u0026#34;); } } public class ConcreteSubsystemB implements SubsystemB { @Override public void operationB() { System.out.println(\u0026#34;SubsystemB operation B\u0026#34;); } } public class ConcreteSubsystemC implements SubsystemC { @Override public void operationC() { System.out.println(\u0026#34;SubsystemC operation C\u0026#34;); } } // 外观类 public class Facade { private SubsystemA subsystemA; private SubsystemB subsystemB; private SubsystemC subsystemC; public Facade() { subsystemA = new ConcreteSubsystemA(); subsystemB = new ConcreteSubsystemB(); subsystemC = new ConcreteSubsystemC(); } public void operation() { subsystemA.operationA(); subsystemB.operationB(); subsystemC.operationC(); } } // 客户端代码 public class Client { public static void main(String[] args) { Facade facade = new Facade(); facade.operation(); } } 3、优缺点 0 1 2 3 4 5 6 7 8 9 10 优点： 1) 外观模式对外屏蔽了子系统的细节，因此外观模式降低了客户端对子系统使用的复 杂性 2) 外观模式对客户端与子系统的耦合关系，让子系统内部的模块更易维护和扩展 3) 通过合理的使用外观模式，可以帮我们更好的划分访问的层次 4) 当系统需要进行分层设计时，可以考虑使用Facade模式 5) 在维护一个遗留的大型系统时，可能这个系统已经变得非常难以维护和扩展，此时 可以考虑为新系统开发一个Facade类，来提供遗留系统的比较清晰简单的接口， 让新系统与Facade类交互，提高复用性 6) 不能过多的或者不合理的使用外观模式，使用外观模式好，还是直接调用模块好。 要以让系统有层次，利于维护为目的。 参考资料 设计模式资料 常用结构性模型\n设计模式-视频讲解\n设计模式-原则\n","date":"2023-10-27T00:00:00Z","permalink":"https://justkids.top/p/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%A4%96%E8%A7%82%E6%A8%A1%E5%BC%8F/","title":"设计模式-外观模式"},{"content":"1、模式类型： 结构型 2、定义： 享元模式（Flyweight Pattern） 也叫 蝇量模式: 运用共享技术有效地支持大量细粒度的对象 2) 常用于系统底层开发，解决系统的性能问题。像数据库连接池，里面都是创建好的连接对象，在这些连接对象 中有我们需要的则直接拿来用，避免重新创建，如果没有我们需要的，则创建一个 3) 享元模式能够解决重复对象的内存浪费的问题，当系统中有大量相似对象，需要缓冲池时。不需总是创建新对 象，可以从缓冲池里拿。这样可以降低系统内存，同时提高效率\n3、原理图 3.1 UML类图 3.2 原理角色说明 对原理图的说明-即(模式的角色及职责)\n0 1 2 3 4 5 1) FlyWeight 是抽象的享元角色, 他是产品的抽象类, 同时定义出对象的外部状态和内部状态(后面介绍) 的接口 或实现 1) ConcreteFlyWeight 是具体的享元角色，是具体的产品类，实现抽象角色定义相关业务 2) UnSharedConcreteFlyWeight 是不可共享的角色，一般不会出现在享元工厂。 3) FlyWeightFactory 享元工厂类，用于构建一个池容器(集合)， 同时提供从池中获取对象方法 内部状态和外部状态 比如围棋、五子棋、跳棋，它们都有大量的棋子对象，围棋和五子棋只有黑白两色，跳棋颜色多一点，所以棋子颜 色就是棋子的内部状态；而各个棋子之间的差别就是位置的不同，当我们落子后，落子颜色是定的，但位置是变化 的，所以棋子坐标就是棋子的外部状态\n享元模式提出了两个要求：细粒度和共享对象。这里就涉及到内部状态和外部状态了，即将对象的信息分为两 个部分：内部状态和外部状态 内部状态指对象共享出来的信息，存储在享元对象内部且不会随环境的改变而改变 外部状态指对象得以依赖的一个标记，是随环境改变而改变的、不可共享的状态 3、应用场景 享元模式经典的应用场景就是:\n0 池技术了，String 常量池、数据库连接池、缓冲池等等都是享元模式的应用，享元模式是池技术的重要实现方式 代码实例 0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 public interface Car { void drive(String location); } // 具体享元实现类 public class ConcreteCar implements Car { private String brand; // 内部状态 public ConcreteCar(String brand) { this.brand = brand; } @Override public void drive(String location) { System.out.println(\u0026#34;Driving \u0026#34; + brand + \u0026#34; to \u0026#34; + location); } } // 享元工厂 public class CarFactory { private Map\u0026lt;String, Car\u0026gt; cars = new HashMap\u0026lt;\u0026gt;(); public Car getCar(String brand) { Car car = cars.get(brand); if (car == null) { // 如果享元池中不存在该品牌的车辆，则创建新的享元对象并放入享元池中 car = new ConcreteCar(brand); cars.put(brand, car); } return car; } } // 客户端代码 public class Client { public static void main(String[] args) { CarFactory carFactory = new CarFactory(); // 获取享元对象并设置外部状态 Car car1 = carFactory.getCar(\u0026#34;Toyota\u0026#34;); car1.drive(\u0026#34;New York\u0026#34;); Car car2 = carFactory.getCar(\u0026#34;Toyota\u0026#34;); car2.drive(\u0026#34;Los Angeles\u0026#34;); Car car3 = carFactory.getCar(\u0026#34;BMW\u0026#34;); car3.drive(\u0026#34;San Francisco\u0026#34;); // 对比对象引用，可以看到car1和car2是同一个对象，而car3是另一个对象 System.out.println(\u0026#34;car1 == car2: \u0026#34; + (car1 == car2)); // true System.out.println(\u0026#34;car1 == car3: \u0026#34; + (car1 == car3)); // false } } 参考资料 设计模式资料 常用结构性模型\n设计模式-视频讲解\n设计模式-原则\n","date":"2023-10-27T00:00:00Z","permalink":"https://justkids.top/p/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E4%BA%94-%E4%BA%AB%E5%85%83%E6%A8%A1%E5%BC%8F/","title":"设计模式之五 享元模式"},{"content":"设计模式-UML 基础知识 1、什么是UML图 即Unified Modeling Language，翻译为：统一建模语言。是用来对软件密集系统进行可视化建模的一种语言。一份典型的建模图表通常包含几个块或框，连接线和作为模型附加信息之用的文本。这些虽简单却非常重要，在UML规则中相互联系和扩展。\nUML立足于对事物的实体、性质、关系、结构、状态和动态变化过程的全程描述和反映。UML可以从不同角度描述人们所观察到的软件视图，也可以描述在不同开发阶段中的软件的形态\nUML采用一组图形符号来描述软件模型，这些图形符号具有简单、直观和规范的特点，开发人员学习和掌握起来比较简单。所描述的软件模型，可以直观地理解和阅读，由于具有规范性，所以能够保证模型的准确、一致\n2、 UML图的作用 UML是一个通用的标准建模语言， 可以对任何具有静态结构和动态行为的系统进行建模，而且适用于系统开发的不同阶段，从需求规格描述直至系统完成后的测试和维护。\n3、UML 的类图关系 类图的6种关系:\n0 1 2 实现（Realization）、泛化（Generalization） 关联（Association）、聚合（Aggregation） 组合(Composition)、依赖(Dependency) ---- #### 3.1 实现关系（Realization） 实现关系：使用的是一个带空心箭头的虚线表示。\n上述类图我们可以说A实现了B，B是一个抽象概念， 在现实中无法直接用来定义对象，只有指明具体的子类，才能用来定义对象.\n3.2 泛化关系 泛化关系:实际上是对类的一个细分， (转)看懂类图——UML类图基础\n最终代码中，泛化关系表现为继承非抽象类；\n3.3 聚合关系 聚合关系： 整体与部分之间是弱依赖关系，整体不存在了，部分依然可以独立存在，也就是说部分和整体的生命周期是独立的。 聚合关系在UML中使用带空心菱形的实线表示\n例如班级不存在了，学生仍然能够单独存在\n3.4 组合关系 组合关系： 整体与部分之间是强依赖关系， 整体不存在了，部分也就不存在了。例如公司与部门之间的关系 组合关系在UML中使用实心菱形的实线表示 (转)看懂类图——UML类图基础\n3.5 关联关系 关联关系:是用一条直线表示的；它描述不同类的对象之间的结构关系； 它是一种静态关系， 通常与运行状态无关，一般由常识等因素决定的。 它一般用来定义对象之间静态的、天然的结构。 所以，关联关系是一种“强关联”的关系； 比如，乘车人和车票之间就是一种关联关系 关联关系默认不强调方向，表示对象间相互知道；如果特别强调方向，如下图，表示A知道B，但 B不知道A，如下图 (转)看懂类图——UML类图基础 注：在最终代码中，关联对象通常是以成员变量的形式实现的；\n3.6 依赖关系 依赖关系是用一套带箭头的虚线表示的\n如下图表示A依赖于B；它描述一个对象在运行期间会用到另一个对象的关系； (转)看懂类图——UML类图基础 显然，依赖也有方向，双向依赖是一种非常糟糕的结构，我们总是应该保持单向依赖，杜绝双向依赖的产生.\n在最终代码中，依赖关系体现为类构造方法及类方法的传入参数，箭头的指向为调用关系；依赖关系除了临时知道对方外，还“使用”对方的方法和属性.\n参考资料 设计模式资料 设计模式-视频\n","date":"2022-12-01T00:00:00Z","permalink":"https://justkids.top/p/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-1-uml/","title":"设计模式-1-UML"},{"content":"1、模式 1、模式类型： 创建型 2、定义： 抽象工厂模式（Abstract Factory Pattern）是围绕一个超级工厂创建其他工厂。该超级工厂又称为其他工厂的工厂。这种类型的设计模式属于创建型模式，它提供了一种创建对象的最佳方式。\n3、原理类图 4、工作原理 0 1 2 3 4 5 抽象工厂模式包含以下几个核心角色： 抽象工厂（Abstract Factory）：声明了一组用于创建产品对象的方法，每个方法对应一种产品类型。抽象工厂可以是接口或抽象类。 具体工厂（Concrete Factory）：实现了抽象工厂接口，负责创建具体产品对象的实例。 抽象产品（Abstract Product）：定义了一组产品对象的共同接口或抽象类，描述了产品对象的公共方法。 具体产品（Concrete Product）：实现了抽象产品接口，定义了具体产品的特定行为和属性。 2、实例： 3、注意事项 优点：\n0 1 2 封装性：抽象工厂模式将对象的创建封装在一个工厂类中，客户端只需要与工厂类进行交互，而无需了解具体对象的创建过程，从而实现了代码的封装性。 可替换性：通过抽象工厂接口，可以轻松地替换具体的工厂类以创建不同系列的对象，而不会对客户端代码造成影响，提供了系统的灵活性和可扩展性。 产品一致性：抽象工厂模式确保了一系列相关对象的一致性，因为它们是由同一个工厂创建的，保证了这些对象之间的兼容性和互操作性。 缺点：\n0 1 2 扩展困难：当需要增加新的产品系列时，需要修改抽象工厂的接口和所有的具体工厂类，违反了开闭原则，可能会导致系统的稳定性受到影响。 类的个数增加：每个具体工厂类只能创建一种系列的产品，如果系统需要创建更多的产品系列，就需要增加新的具体工厂类，这会增加系统中类的个数，增加了代码的复杂性。 产品族扩展困难：当需要增加新的产品族时，除了新增具体产品类外，还需要修改抽象工厂的接口和所有的具体工厂类，违反了开闭原则。 4、应用场景 参考资料 设计模式-创建\n","date":"2022-12-01T00:00:00Z","permalink":"https://justkids.top/p/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E6%8A%BD%E8%B1%A1%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/","title":"设计模式-抽象工厂模式"},{"content":"模式划分三种类型 1、行为型 2、结构型 3、创建型 常用模型: 红色标记\n创建型模式 共五种: 工厂方法模式、抽象工厂模式、单例模式、建造者模式、原型模式。\n结构型模式 共七种: 外观模式、适配器模式、装饰器模式、代理模式、桥接模式、组合模式、享元模式\n行为型模式 共十一种 模板方法模式、策略模式、观察者模式、迭代子模式、责任链模式、命令模式、备忘录模式、状态模式、访问者模式、中介者模式、解释器模式。\n参考资料 设计模式资料 常用结构性模型\n设计模式-视频讲解\n","date":"2022-12-01T00:00:00Z","permalink":"https://justkids.top/p/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E7%BB%93%E6%9E%84/","title":"设计模式-结构"},{"content":"设计模式七原则 编写软件过程中，程序员面临着来自 耦合性，内聚性以及可维护性，可扩展性，重 用性，灵活性 等多方面的挑战，设计模式是为了让程序(软件)，具有更好\n0 1 2 3 4 1) 代码重用性 (即:相同功能的代码，不用多次编写) 2) 可读性(即:编程规范性,便于其他程序员的阅读和理解) 3) 可扩展性 (即:当需要增加新的功能时，非常的方便，称为可维护) 4) 可靠性 (即:当我们增加新的功能后，对原来的功能没有影响) 5) 使程序呈现高内聚，低耦合的特性 面向对象设计原则 对接口编程而不是对实现编程。 优先使用对象组合而不是继承。 一. 单一原则(Single responsibility) 介绍 单一职责原则注意事项和细节：\n1、降低类的复杂度，一个类只负责一项职责 2、提高类的可读性，可维护性； 3、降低变更引起的风险; 4、通常情况下，应当遵守单一职责原则， 只有逻辑足够简单，才可以在方法级违反单一职责原则。\n0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 /** * @author * 只有类中方法数量足够少，可以在方法级别保持单一职责原则 */ public class SingleResponsility { public static void main(String[] args) { Vehicle vehicle = new Vehicle(); vehicle.run(\u0026#34;布加迪威龙\u0026#34;); vehicle.fly(\u0026#34;波音747\u0026#34;); } } // 逻辑简单，方法级别实现单一职责 // 逻辑复杂，分类实现单一职责 class Vehicle { public void run(String string) { System.out.println(string + \u0026#34;：是陆地交通工具\u0026#34;); } public void fly(String string) { System.out.println(string + \u0026#34;：是空中交通工具\u0026#34;); } } 二. 接口隔离原则（Interface Segregation） 介绍 客户端不应该依赖它不需要的接口，即一个类对另一个类的依赖应该建立在最小的接口上\n** 不符合设计模式UML** 分析： ​ 1）类A通过接口Interface1依赖类B，类C通过 接口Interface1依赖类D，如果接口 Interface1对于类A和类C来说不是最小接口， 那么类B和类D必须去实现他们不需要的方法。\n​ 2）按隔离原则应当这样处理\n​ 将接口Interface1拆分为独立的几个接口， 类A和类C分别与他们需要的接口建立依赖关系。也就是采用接口隔离原则\n接口隔离模式UML 应传统方法的问题和使用接口隔离原则改进\n1、类A通过接口 Interface1、2 依赖类B，类C通过接口 Interface1、 3 依赖类D，如果接口 Interface 对于 类A 和 类C 来说不是最小接口，那么 类B 和 类D 必须去实现他们不需要的方法。 2、将接口 Interface 拆分为独立的几个接口，类A 和 类C 分别与他们需要的接口建立依赖关系。也就是采用接口隔离原则。 3、接口 Interface 中出现的方法，根据实际情祝拆分为三个接口。 代码\n0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 public class InterfaceSegregation { public static void main(String[] args) { A a = new A(); a.depend1(new B()); a.depend2(new B()); a.depend3(new B()); C c = new C(); c.depend1(new D()); c.depend4(new D()); c.depend5(new D()); } } interface interface1 { void Operation1(); } interface interface2 { void Operation2(); void Operation3(); } interface interface3 { void Operation4(); void Operation5(); } class B implements interface1, interface2 { @Override public void Operation1() { System.out.println(\u0026#34;B 实现了 Operation1\u0026#34;); } @Override public void Operation2() { System.out.println(\u0026#34;B 实现了 Operation2\u0026#34;); } @Override public void Operation3() { System.out.println(\u0026#34;B 实现了 Operation3\u0026#34;); } } class D implements interface1, interface3 { @Override public void Operation1() { System.out.println(\u0026#34;D 实现了 Operation1\u0026#34;); } @Override public void Operation4() { System.out.println(\u0026#34;D 实现了 Operation4\u0026#34;); } @Override public void Operation5() { System.out.println(\u0026#34;D 实现了 Operation5\u0026#34;); } } class A { public void depend1(interface1 i) { i.Operation1(); } public void depend2(interface2 i) { i.Operation2(); } public void depend3(interface2 i) { i.Operation3(); } } class C { public void depend1(interface1 i) { i.Operation1(); } public void depend4(interface3 i) { i.Operation4(); } public void depend5(interface3 i) { i.Operation5(); } } 三. 依赖倒转原则（Dependence Inversion） 基本介绍 ​ 1) 高层模块不应该依赖低层模块，二者都应该依赖其抽象\n​ 2) 抽象不应该依赖细节，细节应该依赖抽象\n​ 3) 依赖倒转(倒置)的中心思想是：面向接口编程\n​ 4) 依赖倒转原则是基于这样的设计理念： 相对于细节的多变性，抽象的东西要稳定的多。以抽象为基础搭建的架构比以细节为基础的架构要稳定的多。在java中，抽象指的是接口或抽象类，细节就是具体的实现类\n​ 5) 使用接口或抽象类的目的是制定好规范，而不涉及任何具体的操作，把展现细节的任务交给他们的实现类去完成\n依赖倒转原则注意事项和细节 ​ 1) 低层模块尽量都要有抽象类或接口，或者两者都有，程序稳定性更好 ​ 2) 变量的声明类型尽量是抽象类或接口, 这样我们的变量引用和实际对象间，就存在 一个缓冲层，利于程序扩展和优化\n​ 3) 继承时遵循里氏替换原则\n依赖关系三种传递方式： 接口传递（依赖） 构造方法传递（依赖） setter方式传递（聚合） 0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 public class DependenceInversion { public static void main(String[] args) { Person person = new Person(); person.receive(new Email()); person.receive(new WeChat()); } } interface Info{ String getInfo(); } class Email implements Info{ @Override public String getInfo() { return \u0026#34;Receive Email\u0026#34;; } } class WeChat implements Info{ @Override public String getInfo() { return \u0026#34;Receive WeChat\u0026#34;; } } //person 接受信息 class Person { public void receive(Info info) { System.out.println(info.getInfo()); } } 四. 里氏替换原则（Liskov Substitution Principle） 基本介绍 里氏替换原则(Liskov Substitution Principle)在1988 年，由麻省理工学院的Barbara Liskov提出的。 所有引用基类的地方必须能透明地使用其子类的对象。 子类必须完全实现父类的抽象方法，但不能覆盖父类的非抽象方法 当子类实现父类的抽象方法时，方法的后置条件要比父类严格 里氏替换原则告诉我们:\n继承实际上让两个类耦合性增强了，在适当的情况下，可以通过聚合，组合，依赖 来解决问题 在使用继承时，遵循里氏替换原则，在子类中不要重写父类的方法 OO 中的继承性的思考和说明 继承包含这样一层含义：父类中凡是已经实现好的方法，实际上是在设定规范和契约，虽然它不强制要求所有 的子类必须遵循这些契约，但是如果子类对这些已经实现的方法任意修改，就会对整个继承体系造成破坏。\n继承在给程序设计带来便利的同时，也带来了弊端。比如使用继承会给程序带来侵入性，程序的可移植性降低， 增加对象间的耦合性，如果一个类被其他的类所继承，则当这个类需要修改时，必须考虑到所有的子类，并且 父类修改后，所有涉及到子类的功能都有可能产生故障\n问题提出：在编程中，如何正确的使用继承? =\u0026gt; 里氏替换原则\n五. 开闭原则(Open Close Principle) 软件实体（模块、类、方法等）应该\u0026ldquo;对扩展开放、对修改关闭\u0026rdquo;. 最基础，最重要的原则\n从定义上看，这个原则主要包含两部分:\n1 对扩展开放 这意味着模块的行为是可以扩展的。当应用程序的需求改变时，我们可以对其模块进行扩展，使其具有满足那些需求变更的新行为。换句话说，我们可以改变模块的功能。\n2 对修改关闭 “对模块行为进行扩展时，不必改动该模块的源代码或二进制代码。模块的二进制可执行版本，无论是可链接的库、DLL或Java的.jar文件，都无需改动\n0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 //main public static void main(String[] args) { //使用看看存在的问题 GraphicEditor graphicEditor = new GraphicEditor(); graphicEditor.drawShape(new Rectangle()); graphicEditor.drawShape(new Circle()); graphicEditor.drawShape(new Triangle()); graphicEditor.drawShape(new OtherGraphic()); } //这是一个用于绘图的类 [使用方] class GraphicEditor { //接收Shape 对象，调用draw 方法 public void drawShape(Shape s) { s.draw(); } } //新增画三角形 class Triangle extends Shape { Triangle() { super.m_type = 3; } @Override public void draw() { // TODO Auto-generated method stub System.out.println(\u0026#34; 绘制三角形 \u0026#34;); } } //新增一个图形 class OtherGraphic extends Shape { OtherGraphic() { super.m_type = 4; } @Override public void draw() { // TODO Auto-generated method stub System.out.println(\u0026#34; 绘制其它图形 \u0026#34;); } } abstract class Shape { int m_type; public abstract void draw();//抽象方法 } 六. 迪米特法则 (Demeter Principle) 基本介绍 一个对象应该对其他对象保持最少的了解 类与类关系越密切，耦合度越大 迪米特法则(Demeter Principle)又叫最少知道原则，即一个类对自己依赖的类知道的 越少越好。也就是说，对于被依赖的类不管多么复杂，都尽量将逻辑封装在类的内 部。对外除了提供的public 方法，不对外泄露任何信息 迪米特法则还有个更简单的定义:只与直接的朋友通信 直接的朋友: 每个对象都会与其他对象有耦合关系只要两个对象之间有耦合关系， 我们就说这两个对象之间是朋友关系。耦合的方式很多，依赖，关联，组合，聚合 等。其中，我们称出现成员变量，方法参数，方法返回值中的类为直接的朋友，而 出现在局部变量中的类不是直接的朋友。也就是说，陌生的类最好不要以局部变量 的形式出现在类的内部。 迪米特法则注意事项和细节 迪米特法则的核心是降低类之间的耦合 但是注意:由于每个类都减少了不必要的依赖，因此迪米特法则只是要求降低 类间(对象间)耦合关系， 并不是要求完全没有依赖关系 代码 0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 public class Demeter1 { public static void main(String[] args) { //创建了一个 SchoolManager 对象 SchoolManager schoolManager = new SchoolManager(); //输出学院的员工id 和 学校总部的员工信息 schoolManager.printAllEmployee(new CollegeManager()); } } //学校总部员工类 class Employee { private String id; public void setId(String id) { this.id = id; } public String getId() { return id; } } //学院的员工类 class CollegeEmployee { private String id; public void setId(String id) { this.id = id; } public String getId() { return id; } } //管理学院员工的管理类 class CollegeManager { //返回学院的所有员工 public List\u0026lt;CollegeEmployee\u0026gt; getAllEmployee() { List\u0026lt;CollegeEmployee\u0026gt; list = new ArrayList\u0026lt;CollegeEmployee\u0026gt;(); for (int i = 0; i \u0026lt; 10; i++) { //这里我们增加了10 个员工到 list CollegeEmployee emp = new CollegeEmployee(); emp.setId(\u0026#34;学院员工id= \u0026#34; + i); list.add(emp); } return list; } //输出学院员工的信息 public void printEmployee() { //获取到学院员工 List\u0026lt;CollegeEmployee\u0026gt; list1 = getAllEmployee(); System.out.println(\u0026#34;------------学院员工------------\u0026#34;); for (CollegeEmployee e : list1) { System.out.println(e.getId()); } } } //学校管理类 //分析 SchoolManager 类的直接朋友类有哪些 Employee、CollegeManager //CollegeEmployee 不是 直接朋友 而是一个陌生类，这样违背了 迪米特法则 class SchoolManager { //返回学校总部的员工 public List\u0026lt;Employee\u0026gt; getAllEmployee() { List\u0026lt;Employee\u0026gt; list = new ArrayList\u0026lt;Employee\u0026gt;(); for (int i = 0; i \u0026lt; 5; i++) { //这里我们增加了5 个员工到 list Employee emp = new Employee(); emp.setId(\u0026#34;学校总部员工id= \u0026#34; + i); list.add(emp); } return list; } //该方法完成输出学校总部和学院员工信息(id) void printAllEmployee(CollegeManager sub) { //分析问题 //1. 将输出学院的员工方法，封装到CollegeManager sub.printEmployee(); //获取到学校总部员工 List\u0026lt;Employee\u0026gt; list2 = this.getAllEmployee(); System.out.println(\u0026#34;------------学校总部员工------------\u0026#34;); for (Employee e : list2) { System.out.println(e.getId()); } } } 七. 合成复用原则(Composite Reuse Principle) 基本介绍： 原则是尽量使用合成/聚合的方式，而不是使用继承\n1、找出应用中可能需要变化之处，把它们独立出来，不要和那些不需要变化的代码混在一起。 2、针对接口编程，而不是针对实现编程。 3、为了交互对象之间的松耦合设计而努力。 参考资料 设计模式资料\n设计模式教程\n设计模式-视频讲解\n设计模式-图灵星球\n设计模式-原则\n","date":"2022-12-01T00:00:00Z","permalink":"https://justkids.top/p/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E4%B8%83%E5%8E%9F%E5%88%99/","title":"设计模式-七原则"},{"content":"1、适配器模式 1、模式类型： 结构型 2、定义：适配器模式（Adapter Pattern）\n将一个类的接口转换成客户希望的另外一个接口。适配器模式使得原本由于接口不兼容而不能一起工作的那些类可以一起工作。其别名为包装器(Wrapper) 3、适配器分三类：\n0 1 2 类适配器模式、 对象适配器模式、 接口适配器模式 4、工作原理\n0 1 2 3 1) 适配器模式：将一个类的接口转换成另一种接口.让原本接口不兼容的类可以兼容 2) 从用户的角度看不到被适配者，是解耦的 3) 用户调用适配器转化出来的目标接口方法，适配器再调用被适配者的相关接口方法 4) 用户收到反馈结果，感觉只是和目标接口交互，如图 2、原理uml图 3、实例： 0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 //类适配器 public class Client { public static void main(String[] args) { // TODO Auto-generated method stub Phone phone = new Phone(); phone.charging(new VoltageAdapter()); } } public class Phone { public void charging(IVoltage5V iVoltage5V) { if(iVoltage5V.output5V() == 5) { System.out.println(\u0026#34;V5~~\u0026#34;); } else if (iVoltage5V.output5V() \u0026gt; 5) { System.out.println(\u0026#34;220~~\u0026#34;); } } } public interface IVoltage5V { public int output5V(); } public class Voltage220V { //220V public int output220V() { int src = 220; System.out.println(\u0026#34;Voltage220V=\u0026#34; + src); return src; } } public class VoltageAdapter extends Voltage220V implements IVoltage5V { @Override public int output5V() { // TODO Auto-generated method stub int srcV = output220V(); int dstV = srcV / 44 ; return dstV; } } 4、应用场景 0 1 2 3 4 1 封装有缺陷的接口设计 2 统一多个类的接口设计 3 替换依赖的外部系统 4 兼容老版本接口 5 适配不同格式的数据 参考资料 设计模式资料 常用结构性模型\n设计模式-视频讲解\n设计模式-原则\n","date":"2022-12-01T00:00:00Z","permalink":"https://justkids.top/p/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F/","title":"设计模式-适配器模式"},{"content":"1、命令模式 1、模式类型： 行为型 2、基本介绍： 命令模式（Command Pattern）： 在软件设计中，我们经常需要向某些对象发送请求，但是并不知道请求的接收 者是谁，也不知道被请求的操作是哪个，我们只需在程序运行时指定具体的请求接收者即可，此时，可以使用命令模式来进行设计。\n命名模式使得请求发送者与请求接收者消除彼此之间的耦合，让对象之间的调用关系更加灵活，实现解耦。 在命名模式中，会将一个请求封装为一个对象，以便使用不同参数来表示不同的请求(即命名)，同时命令模式 也支持可撤销的操作。 3、原理图 2、实例代码： 3、注意事项 将发起请求的对象与执行请求的对象解耦。发起请求的对象是调用者，调用者只要调用命令对象的execute()方 法就可以让接收者工作，而不必知道具体的接收者对象是谁、是如何实现的，命令对象会负责让接收者执行请 求的动作，也就是说：”请求发起者”和“请求执行者”之间的解耦是通过命令对象实现的，命令对象起到了 纽带桥梁的作用。 2) 容易设计一个命令队列。只要把命令对象放到列队，就可以多线程的执行命令 3) 容易实现对请求的撤销和重做 4) 命令模式不足：可能导致某些系统有过多的具体命令类，增加了系统的复杂度，这点在在使用的时候要注意 5) 空命令也是一种设计模式，它为我们省去了判空的操作。在上面的实例中，如果没有用空命令，我们每按下一 个按键都要判空，这给我们编码带来一定的麻烦。\n4、应用场景 0 1 界面的一个按钮都是一条命令、 模拟CMD（DOS 命令）订单的撤销/恢复、触发-反馈机制 参考资料 设计模式-代理模式 动态dialing-cgib 常用结构性模型\n设计模式-视频讲解\n设计模式-原则\n","date":"2022-12-01T00:00:00Z","permalink":"https://justkids.top/p/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E8%A1%8C%E4%B8%BA%E5%9E%8B-1-%E5%91%BD%E4%BB%A4%E6%A8%A1%E5%BC%8F/","title":"设计模式-行为型-1 命令模式"},{"content":"1、原型模式 1、模式类型： 结构型 2、定义：原型模式（Prototype Pattern）\n参考资料 设计模式资料 常用结构性模型\n设计模式-视频讲解\n设计模式-原则\n","date":"2022-12-01T00:00:00Z","permalink":"https://justkids.top/p/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%8E%9F%E5%9E%8B%E6%A8%A1%E5%BC%8F/","title":"设计模式-原型模式"},{"content":"1、模式 1、模式类型： 结构型 2、定义： 3、原理类图 4、工作原理 2、实例： 3、注意事项 4、应用场景 参考资料 设计模式资料 常用结构性模型\n设计模式-视频讲解\n设计模式-原则\n","date":"2022-12-01T00:00:00Z","permalink":"https://justkids.top/p/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E7%BB%93%E6%9E%84%E5%9E%8B%E4%B9%8B%E4%B8%89-%E5%A4%96%E8%A7%82%E6%A8%A1%E5%BC%8F/","title":"设计模式【结构型】之三 外观模式"},{"content":"1、适配器模式 1、模式类型： 结构型 2、定义：适配器模式（Adapter Pattern）\n将一个类的接口转换成客户希望的另外一个接口。适配器模式使得原本由于接口不兼容而不能一起工作的那些类可以一起工作。其别名为包装器(Wrapper) 3、适配器分三类：\n0 1 2 类适配器模式、 对象适配器模式、 接口适配器模式 4、工作原理\n0 1 2 3 1) 适配器模式：将一个类的接口转换成另一种接口.让原本接口不兼容的类可以兼容 2) 从用户的角度看不到被适配者，是解耦的 3) 用户调用适配器转化出来的目标接口方法，适配器再调用被适配者的相关接口方法 4) 用户收到反馈结果，感觉只是和目标接口交互，如图 2、原理uml图 3、实例： 4、应用场景 0 1 2 3 4 1 封装有缺陷的接口设计 2 统一多个类的接口设计 3 替换依赖的外部系统 4 兼容老版本接口 5 适配不同格式的数据 参考资料 设计模式资料 常用结构性模型\n设计模式-视频讲解\n设计模式-原则\n","date":"2022-12-01T00:00:00Z","permalink":"https://justkids.top/p/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E7%BB%93%E6%9E%84%E5%9E%8B%E4%B9%8B%E4%B8%89-%E7%BB%84%E5%90%88%E6%A8%A1%E5%BC%8F/","title":"设计模式【结构型】之三 组合模式"},{"content":"1 桥接模式 1.1 定义： 桥接模式（Bridge Pattern）\n将抽象部分与它的实现分离，使它们都可以独立地变化。 更容易理解的表述是：实现系统可从多种维度分类，桥接模式将各维度抽象出来，各维度独立变化，之后可通过聚合，将各维度组合起来，减少了各维度间的耦合。\n参考资料 设计模式资料 常用结构性模型\n设计模式-视频讲解\n设计模式-原则\n","date":"2022-12-01T00:00:00Z","permalink":"https://justkids.top/p/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E7%BB%93%E6%9E%84%E5%9E%8B%E4%B9%8B%E4%B8%80-%E6%A1%A5%E6%8E%A5%E6%A8%A1%E5%BC%8F/","title":"设计模式【结构型】之一 桥接模式"},{"content":"1、备忘录模式 1、模式类型： 行为型 2、定义： 备忘录模式（Memento Pattern）保存一个对象的某个状态，以便在适当的时候恢复对象。备忘录模式属于行为型模式。 3、工作原理 0 1 2 3 4 5 6 7 8 意图：在不破坏封装性的前提下，捕获一个对象的内部状态，并在该对象之外保存这个状态。 主要解决：所谓备忘录模式就是在不破坏封装的前提下，捕获一个对象的内部状态，并在该对象之外保存这个状态，这样可以在以后将对象恢复到原先保存的状态。 何时使用：很多时候我们总是需要记录一个对象的内部状态，这样做的目的就是为了允许用户取消不确定或者错误的操作，能够恢复到他原先的状态，使得他有\u0026#34;后悔药\u0026#34;可吃。 如何解决：通过一个备忘录类专门存储对象状态。 关键代码：客户不与备忘录类耦合，与备忘录管理类耦合。 4、原理类图 2、实例： 3、注意事项 0 1 2 3 4 优点： 1、给用户提供了一种可以恢复状态的机制，可以使用户能够比较方便地回到某个历史的状态。 2、实现了信息的封装，使得用户不需要关心状态的保存细节。 缺点：消耗资源。如果类的成员变量过多，势必会占用比较大的资源，而且每一次保存都会消耗一定的内存。 4、应用场景 1、存档 2、游戏角色 保存\n参考资料 备忘录模式详解 设计模式资料 常用结构性模型\n设计模式-视频讲解\n设计模式-原则\n","date":"2022-12-01T00:00:00Z","permalink":"https://justkids.top/p/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E8%A1%8C%E4%B8%BA%E5%A4%87%E5%BF%98%E5%BD%95%E6%A8%A1%E5%BC%8F/","title":"设计模式【行为】备忘录模式"},{"content":"1、模式 1、模式类型： 结构型 2、定义： 3、原理类图 4、工作原理 2、实例： 3、注意事项 4、应用场景 参考资料 备忘录模式详解 设计模式资料 常用结构性模型\n","date":"2022-12-01T00:00:00Z","permalink":"https://justkids.top/p/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E8%A1%8C%E4%B8%BA%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F/","title":"设计模式【行为】策略模式"},{"content":"1、解释器模式 1、模式类型： 行为型 2、定义： 解释器模式（Interpreter Pattern）提供了评估语言的语法或表达式的方式，它属于行为型模式。这种模式实现了一个表达式接口，该接口解释一个特定的上下文。这种模式被用在 SQL 解析、符号处理引擎等。\n3、工作原理 0 1 2 3 4 5 6 7 8 意图：在不破坏封装性的前提下，捕获一个对象的内部状态，并在该对象之外保存这个状态。 主要解决：所谓备忘录模式就是在不破坏封装的前提下，捕获一个对象的内部状态，并在该对象之外保存这个状态，这样可以在以后将对象恢复到原先保存的状态。 何时使用：很多时候我们总是需要记录一个对象的内部状态，这样做的目的就是为了允许用户取消不确定或者错误的操作，能够恢复到他原先的状态，使得他有\u0026#34;后悔药\u0026#34;可吃。 如何解决：通过一个备忘录类专门存储对象状态。 关键代码：客户不与备忘录类耦合，与备忘录管理类耦合。 4、原理类图 2、实例： 3、注意事项 0 1 2 3 4 优点： 1、给用户提供了一种可以恢复状态的机制，可以使用户能够比较方便地回到某个历史的状态。 2、实现了信息的封装，使得用户不需要关心状态的保存细节。 缺点：消耗资源。如果类的成员变量过多，势必会占用比较大的资源，而且每一次保存都会消耗一定的内存。 4、应用场景 1、存档 2、游戏角色 保存\n参考资料 备忘录模式详解 设计模式资料 常用结构性模型\n设计模式-视频讲解\n设计模式-原则\n","date":"2022-12-01T00:00:00Z","permalink":"https://justkids.top/p/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E8%A1%8C%E4%B8%BA%E8%A7%A3%E9%87%8A%E5%99%A8%E6%A8%A1%E5%BC%8F/","title":"设计模式【行为】解释器模式"},{"content":"1、模式 1、模式类型： 结构型 2、定义： 3、原理类图 4、工作原理 2、实例： 3、注意事项 4、应用场景 参考资料 设计模式资料 常用结构性模型\n设计模式-视频讲解\n设计模式-原则\n","date":"2022-12-01T00:00:00Z","permalink":"https://justkids.top/p/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E8%A1%8C%E4%B8%BA%E4%B9%8B%E4%BA%8C-%E8%AE%BF%E9%97%AE%E8%80%85%E6%A8%A1%E5%BC%8F/","title":"设计模式【行为】之二 访问者模式"},{"content":"1、模式 1、模式类型： 结构型 2、定义： 3、原理类图 4、工作原理 2、实例： 3、注意事项 4、应用场景 参考资料 设计模式资料 常用结构性模型\n设计模式-视频讲解\n设计模式-原则\n","date":"2022-12-01T00:00:00Z","permalink":"https://justkids.top/p/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E8%A1%8C%E4%B8%BA%E4%B9%8B%E4%BA%8C-%E8%AE%BF%E9%97%AE%E8%80%85%E6%A8%A1%E5%BC%8F/","title":"设计模式【行为】之二 访问者模式"},{"content":"1、模式 1、模式类型： 结构型 2、定义： 3、原理类图 4、工作原理 2、实例： 3、注意事项 4、应用场景 参考资料 备忘录模式详解 设计模式资料 常用结构性模型\n","date":"2022-12-01T00:00:00Z","permalink":"https://justkids.top/p/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E8%A1%8C%E4%B8%BA%E8%81%8C%E8%B4%A3%E9%93%BE%E6%A8%A1%E5%BC%8F/","title":"设计模式【行为】职责链模式"},{"content":"1、模式 1、模式类型： 结构型 2、定义： 3、原理类图 4、工作原理 2、实例： 3、注意事项 4、应用场景 参考资料 备忘录模式详解 设计模式资料 常用结构性模型\n","date":"2022-12-01T00:00:00Z","permalink":"https://justkids.top/p/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E8%A1%8C%E4%B8%BA%E7%8A%B6%E6%80%81%E6%A8%A1%E5%BC%8F/","title":"设计模式【行为】状态模式"},{"content":"1、模式 1、模式类型： 行为型 2、定义： 3、原理类图 4、工作原理 2、实例： 3、注意事项 4、应用场景 参考资料 设计模式资料 常用结构性模型 设计模式\n设计模式-视频讲解\n设计模式-原则\n","date":"2022-12-01T00:00:00Z","permalink":"https://justkids.top/p/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E8%A1%8C%E4%B8%BA%E5%9E%8B%E4%B9%8B%E4%B8%89-%E8%BF%AD%E4%BB%A3%E5%99%A8%E6%A8%A1%E5%BC%8F/","title":"设计模式【行为型】之三 迭代器模式"},{"content":"1、模式类型： 结构型 2、定义： 代理模式：为一个对象提供替身\n3、静态代理 3.1 介绍 4、动态代理 2、实例： 3、应用场景 0 1 2 3 4 1 封装有缺陷的接口设计 2 统一多个类的接口设计 3 替换依赖的外部系统 4 兼容老版本接口 5 适配不同格式的数据 参考资料 设计模式-代理模式 动态dialing-cgib 常用结构性模型\n设计模式-视频讲解\n设计模式-原则\n","date":"2022-12-01T00:00:00Z","permalink":"https://justkids.top/p/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F/","title":"设计模式代理模式"},{"content":"亲子环青海湖骑行 出行日期:22年7月22日\n闺女7岁，侄女9岁(出发前2天才学会骑），各位根据具体情况自行安排，不过建议至少要提前锻炼1周，环湖路上车多，没有骑行道(仅19公里)，小朋友很难走直线，骑着就出白线外，需要家长时刻提醒。\nD1 北京-西宁火车站-藏文化博物馆 行程: 坐火车至西宁火车站，上午10点半到。在火车上小朋友就开始咳嗽，一下火车就去了儿童医院（距离火车站很近），医生建议先在西宁市待两天,防止高反引起病情严重，只好调整计划，先在西宁市内转转。\n本打算先去东、西关清真寺，可惜不开放。选择了藏文化博物馆（5:30闭官），3个小时足够转一遍，适合小朋友去学习藏文化，门票60一位，(老师,一米2以上小孩）半价，讲解需提前预约，我们当天到的时候，已经约不上讲解，一路上蹭别人的讲解（讲解还是很有必要的），个人感觉还是很值得去的。\n住宿: 因为要第二天去医院复查，我们定了在离医院和火车站都很近的柏曼酒店，当天预定，二百多一间，房间很大，很干净，推荐（唯一就是上下电梯比较慢）\nD2 急诊室-塔尔寺-西海镇 行程: 继闺女生病后，第二天侄女也感冒，可能昨晚洗澡着凉（强烈建议第一天不要洗澡，不要洗澡），早上带着2个娃又去了急诊室（😔真担心这次旅行就这样结束），幸好医生说不严重,多喝水、吃点药就好（长出一口气)。为了行动更方便，选择在悟空APP租了一天车，服务挺好，直接送车到门口，一天230元。（租2天比较合适，有优惠卷，1天没有）有人租的60一天，不知道怎么租的，还车地在西宁火车站地下停车场(大部分租车点都在这里)。\n塔尔寺:门票70一人,(佛教徒、儿童半价) 讲解5人160，10人200。我们的讲解员是位名为$\\color{red}{李娟}$的小姑娘，人非常热心（推荐）\n$\\color{red}{塔尔寺注意事项:}$ 1、不要穿漏膝裙子，内部不要拍照，不要随便拜（小孩有的拜姻缘佛） 2、转经筒顺时针转、不要单手指指佛像。 1、小插曲 讲解员听孩子饿了，向寺里的僧人问有没有吃的，僧人说有饼，我们礼貌性的拒绝。僧人道：“藏民都会要，汉民一般都不要”，后来越想越后悔(对有信仰的人来说是很好的佛缘）。如果在寺里，遇到僧人给东西就愉快的接着，僧人也会很高兴的(只限于寺里)。如果想拜姻缘佛绿度母，是不在讲解范围的，可以请导游给指路。我们的导游不紧带着去了，还帮求了条姻缘绳。\n2、西宁至西海镇 火车站有长途大巴，两小时到达，6点20最后一班，可以网上买好票，30一位。 也可包车到，60一位。当地人应该是100一位，转手转给西海镇出租司机60-70一位， 如果提前有预约，最好联系西海镇的出租司机。\n3、租自行车 别人推荐的517骑行驿站，熟客打8.5折，算下来成人车300一圈，儿童车好像不打折（记不太清）280一圈；一圈3-5天，不管你骑几天都是这个价格。儿童的是新车，配骑行帽、车胎、打气筒、坐垫，一次性雨衣等。小孩墨镜30一个。\n住宿： 旅店:正大睿品，517对面，房间隔音不好，设备还算可以\n备注: 提前买好骑行裤，西海镇什么都没有卖的，超市9点才开门，早上买水都没地。 骑行装备： 最好提前准备好，我们去的迪卡侬买帽子、骑行裤、背包等，但是儿童骑行裤好多店都断货，可以在淘宝官网找到，选择到店自提。上面可以看到哪个店还有货。\nD3 西海镇-湖东种羊场-江西沟(60KM)\u0026ndash;(环湖开始) 行程: $\\color{red}{环湖Day1:}$\n出发前就联系好了517骑行俱乐部，到西海镇当天晚上选好了自行车，第二天早上8点出发，考虑到2个孩子第一天起，规划的是先从西海镇打车到湖东种羊场，开始骑行,完全躲过去了陡坡。（打车到种羊场，一辆出租130，我们五个人五辆车，两辆出租拉，260元） 湖东种羊厂到江西沟将近60KM，沿途油菜花和湖，风景不错，在二郎剑附近有一个通往湖边的路，顺路下去就可以到湖边玩耍，而且免费的，还有海鸟。\n第一天闺女状态不错，骑行大概40KM，还差15公里的时候，一边哭一边骑，喊着骑不动。没办法只好他爸驮着，我驮着她的自行车，7点到酒店。 侄女骑行20KM就开始高反，一路吐。碰到热心的烽火户外骑行队，搭坐保障车一直到二郎剑，随后找了辆皮卡拉到江西沟，20KM收费100元。如果遇到特殊情况，最好提前联系预约的酒店，询问是否可以接（有偿的也比路上价格便宜），万一小朋友体力不支。也不至于手忙脚乱。\n江西沟有一所$\\color{red}{医务室}$(在我们住宿酒店的对面)，医生人很热心和负责。侄女喝了一瓶葡萄糖，吸了1瓶氧气后，就活蹦乱跳起来。\n住宿: 青海湖湖畔花海民俗酒店，120一间，房子是新装修的，装修不错，不冷，24小时热水，对面就是卫生所，是此行住的性价比最高的。\n备注: 骑行第一天，建议一定要备上$\\color{red}{氧气罐,葡萄糖}$，虽说海拔不高，但还是有不少高反，特别是骑车的。沿途店里也有卖的。头晕，呕吐就赶紧吸氧。\nD4 江西沟-黑马河(47KM) 行程: $\\color{red}{环湖Day2:}$\n今天2个小朋友状态都不错，闺女一路上追赶一只学生骑行队，劲头十足。侄女一边吸氧，一边骑，47KM 2个小丫头都坚持骑了下来，我们也是倍感惊讶，替小朋友自豪。 沿途风景依旧美丽，虽离湖边远点，还是挡不住的美。下午4点达到酒店，在办理酒店期间，2个小朋友成了焦点。有告诉侄女应该怎么更有效吸氧，被侄女称作“毛头叔叔”，另一位也一直给闺女加油打气，还开玩笑的说：“想邀请闺女加入他们的团队” 后来了解到是 $\\color{red}{新大陆的杨领队}$在此非常感谢他，在以后旅途中给我们提供了很多帮助。本打算当天去茶卡，杨领队建议“最好第二天早上去，现在去没有太多时间玩”。\n住宿: 旺湖酒店，亲子房250左右一间。接待很多团队，需提前预定。因小朋友生病，造成我们晚了一天才到酒店，预定的时间也没有改，造成差点没房住的尴尬(切记，要核实预定酒店的日期)。最后协商住进了一楼的临时房间，里面很冷，没有地暖。提供了电热毯，算是插曲吧。旁边有个西海酒店看着还行，可以看看网上评价，出酒店就是桥，早上可以沿着河边走到湖边看日出，最好是6点15之前出去看日出，不然就晚了。我们实在太累，错过了日出，有点后悔。\nD5 黑马河-茶卡-鸟岛(57KM)(风景最漂亮，一路下坡) 行程: 茶卡盐湖: 从黑马河出发至茶卡盐湖，一个半小时车程，拼车70一位，谈不下来就找酒店老板，老板能谈到大概80一位；早上7点半出发，9点到大门口， 坐摆渡车到检票口，大概20分钟， 门口直接扫门票电子码,进入步行10分钟乘坐小火车10分钟到达盐湖， 第一站下车，租鞋，10元一双，红裙50一件，鞋子和裙子只有第一站有租的，后面几站人很少，但是没有鞋的，如果想几个湖都转一下，需要第一站租鞋，把所有湖转一圈，再重新做小火车从起点到第一站，相当于需要坐小火车绕两圈，估计最少两小时，因为小火车不走回头路，我们时间紧，只在第一站拍照一小段，从11点开始做小火车往门口走，小火车走的慢悠悠，下了小火车有坐大巴，等了15分钟才发车，到12点才出大门坐上返回黑马河的车，体验很不好，私家车好像能开到检票口。去之前觉得红裙太俗，没准备，到那发现还是红裙拍出来好看，记得给闺女准备漂亮裙子，我们就是穿了一身运动衣去的，遗憾。提前网上买好票，也可以扫包车师傅的码买，他们能积分，对我们来说价钱都是一样的，两个地方，天空之镜和天空一号，一个老景点一个新景点，天空之境门票好像70，小火车109， 天空一号门票+小火车88，天空一号人相对少点，推荐天空一号。\n骑行鸟岛: $\\color{red}{环湖Day3:}$ 从茶卡回来，吃饭，直到下午3点才开始出发，目标57Km，今天除了两个大上坡，一路下坡，很好骑。而且风景是这几天里最漂亮的一天。一定要早点出发，途经一个断崖处离湖最近的地方，可以去湖边玩一会（收费，好像10元）有海鸟，别玩太长时间。晚上温度下降很快，到8点左右骑行就会觉得脚冷，手冷，我们9点多才到目的地，小朋友的手都冻僵了。进酒店第一件事就是找热水暖手。晚上8点多的时候,新大陆的杨领队特意发信息，询问是否需要保障车，可以过来接小朋友(还不断鼓励他们)(非常感谢)。沿途孩子们经过的时候，他们的团队一直给小朋友加油鼓劲。（遗憾是没和他们合一张影）\n住宿: 旅店:海碧假日\n170左右一间，体验不是很好，虽然有地暖和热水，但洗澡是电热水器，需要等好久才烧好，喷头也是坏的，可以在酒店房间看星空，但是因为当晚9点多才到达，太累，没有精力拍星空，孩子们也没看到就睡了。可以看到银河系，很漂亮。\n备注: 如果小朋友骑不动，可以考虑到石乃亥落脚，黑马河到石乃亥40多KM,我们是到石乃亥后，看时间还充裕，孩子状态也OK,孩子姑姑用2个盲盒作为条件，激励他们骑到了鸟岛(物质的力量😁）\nD6 鸟岛-刚察(65KM左右) 行程: $\\color{red}{环湖Day4: end}$\n早上9点出发，骑行2小时，在一个度假村休整，离湖最近，到湖边捡石头，写生，骑🐎，下午2点出发，骑行1小时后，远处就黑云密布，还好我们这里还阳光明媚，只是没想到，没过一会，乌云就笼罩过来，狂风突起，雷雨交加，孩子一下子就慌了，哇哇大哭，自行车也被吹到了沟里。我们手忙脚乱的给孩子穿上雨衣，正在这时，从我们身边路过的一辆皮卡停了下来。说明情况后，将拉孩子们先拉到刚察，礼节性的收了100。老母亲和老父亲6点半才骑行抵达刚察。本以为完美收官，意外总是出乎意料。\n住宿: 海博假日，250一间观景房，缺点：地方稍微有点偏僻，附近吃饭地方少，离刚察人民医院核酸检测的两公里；优点：房间里面设备不错，观景房是看山景，不是湖景\n备注: $\\color{red}{一定一定要考虑核酸报告}$ 刚察核酸6点下班，没有赶上，导致一晚上心情很差，打了一晚上防控中心的电话(咨询那里核酸可以第二天6点前出来)，确切的答复是只有到西宁市去做核酸。如果当天骑行如需做核酸,可以在刚察途中的泉吉乡做(血的教训)\nD7 刚察-西宁（返程） 行程: 早上6：30出发：将近8点到达西海镇 原计划是坐刚察至西海镇的大巴(大巴可以携带自行车），因需赶往西宁做坐核酸，包了个皮卡300元。大巴刚察至西海镇，每半小时一趟，可搭载自行车。\n8:00-8:30 还自行车，顺便做核酸\n8:30-10:00 搭乘出租至西宁 费用260，应该240元也可以，青海大学附属医院，做核酸，唐道休息。时间不紧的话也可以坐大巴到西宁。 6点半 唐道至机场，回京，打滴滴，90元。\n备注: 在西宁不要打出租到机场，出租司机一听到机场，就不打表，直接要价150元，西宁本地同学帮忙还价到120元，同学建议打滴滴，不到90元。\n青海湖: 行程总结 吃饭 当地餐馆菜咸、辣，特意说明不要辣，还是会有辣。肉不好嚼。每顿三菜一汤，够三个大人两个小孩，大概200元。吃了几顿当地菜后我们就开始去川菜馆，更合口味。\n后勤保障: 每天大概50Km左右，有可能遇到下雨或高反等，骑不动的话可以找酒店车去接，江西沟时酒店说10公里内免费，鸟岛的酒店是5公里内免费，可以跟老板协商，也可以路边找牧民的皮卡，或普通轿车拉，一般20公里左右收100元，因为要空跑回去；一个出租可以后备箱可以拉两到三两自行车。还可以找个皮卡作为保障车，加司机可载五人，能拉上所有自行车，去之前咨询的7座商务车一天850元，皮卡一天大概700元。\n关于核酸(一定要规划好，不然会很麻烦) 环湖沿途只有二郎剑，泉吉乡，刚察有，都是6点下班， 第一天途径二郎剑做一个， 第四天途径泉吉乡做一个， 刚察核酸检测点有好几个， 不过都是6点下班，如果带着孩子骑行，想赶上有点困难，一定先去距刚察20公里的泉吉乡做一个，不然很麻烦，我们差10分钟没赶上刚察的核酸，整个青海湖附近没有24小时核酸，整个西宁没有快检，最快的是西宁市一些医院，上午11:30之前做，下午6点之前出结果， 我们为了赶上晚上的飞机，早上6点半刚察包车出发，8点到西海镇还自行车，8点半西海镇出发，10点到西宁$\\color{red}{青海大学附属医院}$（11点前做核酸确定可以6小时出结果），一路真的很困，所以回程核酸一定要提前安排好。\n装备 真的很晒，只带骑行帽的话，额头、鼻梁等露出来的地方晒一天就会晒伤，目前我的鼻梁刚蜕完一层皮。所以最好在骑行帽里面带上太阳帽。 骑行镜：保护眼睛，一定要带，可以墨镜代替 骑行裤：带，实在不想买可以用车行配的座套 保温杯：一定要带，早晚温差大，喝一杯热水感觉很好 骑行最好关注一下天气情况，尽量找连续晴天的时间去\n关于费用 我们（3大2小）的费用，包括火车，飞机票总共：1.5W 不想自己骑行的也可报户外亲子骑行团(很成熟，很多都是北京组团)。如新大陆户外骑行团（非常推荐）。组团不含来回机票:一大一小大概在6000左右， 酒店预定： 因为疫情，很好定，价格也比往年旺季便宜最少一倍， 我们一般是提前一天或当天预定，以后人多了，应该就需要提前预定啦\n","date":"2022-08-02T15:43:00+08:00","image":"https://cdn.staticaly.com/gh/justkids2018/cdn@main/tool/20220803145353.jpeg","permalink":"https://justkids.top/p/%E4%BA%B2%E5%AD%90%E7%8E%AF%E9%9D%92%E6%B5%B7%E6%B9%96%E9%AA%91%E8%A1%8C-%E7%8E%AF%E6%B9%96%E7%AF%87/","title":"亲子环青海湖骑行-环湖篇"},{"content":"亲子环青海湖骑行-路线装备篇 环湖路线图:\n\u003e交通路线: 休闲游玩路线\n借鉴的攻略 环青海湖骑行攻略\n常规环湖路线 0 1 2 3 4 D1 全国各地-西海镇集合 D2 西海镇-乘车25KM-青海湖大门-骑行75KM-江西沟 D3 江西沟-骑行55KM-黑马河 （下午自由活动，可自行前往茶卡盐湖） D4 黑马河-骑行115KM-刚察 D5 刚察-骑行85KM-青海湖大门-乘车25KM-西海镇 解散 亲子环湖路线: 考虑再三，将刚察作为亲子环湖骑行的终点，因刚察之后坡起很多,而且路程长,风景也不如之前，体力也跟不上（只能期待小朋友再大一些，再骑全程）\n0 1 2 3 4 D1 西海镇-(湖东种羊场)-江西沟(65KM) D2 江西沟-骑行55KM-黑马河（57KM） D3 黑马河-石乃亥(42KM)-鸟岛(57KM) D4 鸟岛-刚察(65KM) （终点） D5 刚察-骑行85KM-青海湖大门-乘车25KM-西海镇 (亲子环湖-大巴回城) 物品清单 0 1 2 3 4 1、衣物：冲锋衣、防晒衣、帽子、面巾、手套、雨鞋、运动鞋、秋衣裤、骑行裤、袜子、内衣 2、装备：水杯、眼镜、口罩、防晒霜(必须)、毛巾、洗簌用品，充电宝、雨伞 3、药品（小朋友的药为主）：消炎药,葡萄糖,*氧气瓶*（必备，血的教训） 感冒药、发烧药、藏红花、晕车贴、创可贴、云南白药、膏药 4、画具：纸、油画棒、铅笔、勾线笔、油画笔、绘画本（途中写生） ","date":"2022-08-01T07:13:20+08:00","permalink":"https://justkids.top/p/%E4%BA%B2%E5%AD%90%E7%8E%AF%E9%9D%92%E6%B5%B7%E6%B9%96%E9%AA%91%E8%A1%8C-%E8%B7%AF%E7%BA%BF%E8%A3%85%E5%A4%87%E7%AF%87/","title":"亲子环青海湖骑行-路线装备篇"},{"content":"什么是构建工具 0 1 2 3 4 5 6 7 构建工具是从源代码自动创建可执行应用程序的程序（例如，.apk对于 Android 应用程序）。构建将代码编译、链接和打包成可用或可执行的形式。 基本上，构建自动化是编写脚本或自动化软件开发人员在日常活动中执行的各种任务的行为 如： 下载依赖项。 将源代码编译成二进制代码。 打包该二进制代码。 运行测试。 部署到生产系统。 为什么要使用构建工具 0 在小型项目中，开发人员通常会手动调用构建过程。这对于较大的项目是不切实际的，因为很难跟踪需要构建的内容、构建过程中的顺序和依赖关系。使用自动化工具可以使构建过程更加一致。 各种构建工具 0 1 2 对于 java - Ant、Maven、Gradle。 对于 .NET 框架 - NAnt c# - MsBuild。 参考资料 1、 what art build tool 2、 3、\n","date":"2022-04-28T07:08:06+08:00","permalink":"https://justkids.top/p/%E5%AD%A6%E4%B9%A0gradel_01_%E4%BB%80%E4%B9%88%E6%98%AF%E6%9E%84%E5%BB%BA%E5%B7%A5%E5%85%B7/","title":"学习Gradel_01_什么是构建工具"},{"content":"","date":"2022-04-28T07:08:06+08:00","permalink":"https://justkids.top/p/%E5%AD%A6%E4%B9%A0gradel_02_%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/","title":"学习Gradel_02_基本概念"},{"content":"想法的开始 2020年疫情开始后，微博上出现了很多不同的声音，本身多元的观点很正常，慢慢不同立场开始变的极端，甚至谩骂，诋毁。 尤其我认为是常识的观点，遭到很多人的质疑，而很多还是大学生。也对微博上的一些大V的转变感到疑惑。偶然想起之前的纪录片，关于从童年到中年的10几个主人公的生活经历。 是否也可以抓取公共信息，通过大数据来分析他们的生活经历以及观念的改变。取名为：《01人生》 -2022.4.23 周六下午\n","date":"2022-04-23T17:12:53+08:00","permalink":"https://justkids.top/p/%E5%81%8F%E8%A7%81%E8%B5%B7%E7%82%B9/","title":"《偏见》起点"},{"content":"hugo 参考资料 flutter widget 渲染\n","date":"2022-04-14T15:23:42+08:00","permalink":"https://justkids.top/p/flutter-widiget%E6%B8%B2%E6%9F%93-1/","title":"Flutter widiget渲染-1"},{"content":"github 创建仓库 0 公共仓库 项目名称cdn 本地下载仓库操作 0 git clone 项目仓库地址 上次文件或者图片 0 1 2 git add . git commit -m \u0026#34;first file\u0026#34; git push origin feature(定义的分支) github 发布release 版本 （可进行版本控制，方便迭代）\n增加picGO 的使用方式 下载picgo软件\n0 1 mac os: brew install picgo --cask 2、github上设置tocken设置参数\n3、设置 picgo的具体参数配置：借鉴文章\n4、 上传图片 踩到的坑\n0 1 2 3 4 1、github 最新创建分支默认是main 分支，不再是master 分支 2、picgo 配置自定义域名后缀不加上分支，无法打开上传图片链接（耗费我大半天）郁闷 1）https://cdn.jsdelivr.net/gh/justkids2018/cdn@分支/ 2）另一方式：就是增加版本号 （需要每次都发布reales版本） https://cdn.jsdelivr.net/gh/justkids2018/cdn@version/ 参考方案\n通过JsDelivr 引用资源 jsDelivr 开源的CDN简介\nJsDeliver 引用参数说明\n0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 引用方式： https://cdn.jsdelivr.net/gh/你的用户名/你的仓库名@发布的版本号/文件路径 // 使用特定版本 https://cdn.jsdelivr.net/gh/justkids2018/cdn@1.1.10/test.js // 使用版本范围而不是特定版本 https://cdn.jsdelivr.net/gh/justkids2018/cdn@1.0/test.js // 增加 \u0026#34;.min\u0026#34; to any JS/CSS file to get a minified version //if one doesn\u0026#39;t exist, we\u0026#39;ll generate it for you https://cdn.jsdelivr.net/gh/justkids2018/cdn@1.0/test. min.js // 完全省略该版本以获取最新版本 https://cdn.jsdelivr.net/gh/justkids2018/cdn/test.js // 在末尾添加 / 以获取资源目录列表 https://cdn.jsdelivr.net/gh/justkids2018/cdn/ 2022年8月更新： 0 1 2 3 jsdelivr 与2021年12月 国内无法访问， 图库更新至 https://statically.io/ 域名替换成使用: https://cdn.staticaly.com/gh/ ","date":"2021-08-07T08:45:57+08:00","permalink":"https://justkids.top/p/github--jsdelivr-picgo-cdn-%E6%89%98%E7%AE%A1%E6%96%87%E4%BB%B6%E5%9B%BE%E7%89%87/","title":"Github + jsDelivr+picGO CDN  托管（文件、图片）"},{"content":"《编程》\u0026ndash;隐匿在计算机软硬件背后的语言\n作者: [美] Charles Petzold 副标题: 隐匿在计算机软硬件背后的语言 原作名: Code: The Hidden Language of Computer Hardware and Software 豆瓣:书籍引用\n","date":"2021-08-07T07:13:20+08:00","permalink":"https://justkids.top/p/2022-1-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%E7%BC%96%E7%A8%8B/","title":"2022-1-读书笔记《编程》"},{"content":" 本地工具部署 指南 安装my sql\n借鉴安装教程\n登录mysql\n0 1 2 3 4 mysql -uroot -p ·展示mysql的端口 show global variables like \u0026#39;port\u0026#39;; 可视化Navicat 安装\n借鉴Navicat文档\n0 1 **出现提示app 已经损坏，移除垃圾站，使用一下命令可解决 ： sudo xattr -r -d com.apple.quarantine /Applications/Navicat\\ Premium.app/ Mysql navicat 连接\n借鉴文档\n","date":"2021-08-07T07:13:20+08:00","permalink":"https://justkids.top/p/%E6%9C%8D%E5%8A%A1%E5%99%A8%E9%83%A8%E7%BD%B2%E5%9C%A8%E7%BA%BF%E5%92%8C%E6%9C%AC%E5%9C%B0/","title":"服务器部署在线和本地"},{"content":" 视频编辑注意的问题： 1、字体的侵权问题 免费-\n0 1 2 3 4 5 字体： 1、思源黑体 2、站酷 字体 3、庞门 4、濑户小姐 5、 视频录制工具： 0 1 2 3 录屏软件：ScreenFlow OBS 录音剪辑：Logic Pro X 视频剪辑：Final Cut Pro X 字幕编辑：ArcTime 字幕编辑：ArcTime\n语音识别 1、网易见外 2、讯飞\nbgm 音乐版权 1、音乐库 2、vlog no copyright music 3、\n制作流程 1.脚本制作 2.旁白制作 3.录音 4.音频剪辑 5.视频素材制作 6.视频剪辑 7.标题、简介、缩略图 8.检查和上传\n借鉴项目 老威\n","date":"2021-08-07T07:13:20+08:00","permalink":"https://justkids.top/p/%E8%A7%86%E9%A2%91%E7%BC%96%E8%BE%91%E6%95%99%E7%A8%8B/","title":"视频编辑教程"},{"content":"主题stack下载 0 git clone https://github.com/CaiJimmy/hugo-theme-stack/ themes/hugo-theme-stack config.yaml配置文件 hugo 借鉴资料 Hugo 主题 Stack文档\nHugo 主题 个人\n","date":"2021-08-06T22:06:16+08:00","permalink":"https://justkids.top/p/hugo_stack-%E4%B8%BB%E9%A2%98%E9%85%8D%E7%BD%AE/","title":"Hugo_stack 主题配置"},{"content":"java 面试 问题：char 是两个字节，如何存UTF-8字符 1、char 是什么 （unicode）\n2、UTF-8 是什么\n0 1 2 3 4 Unicode 字符集 不是编码，作用类似于ASCII码 Unicode 通用字符集占两个字节，例如“中” 字符集「ASCII码，Unicode」 char 存储的是（utf-16） 打印出来 字节序标识 java String 的length 不是字符数 ** 需要重新学习基础 字节码，utf-8 utf-16 **\n\u0026mdash;学习进度3-2 java String 可以有多长 ","date":"2021-08-05T22:01:39+08:00","permalink":"https://justkids.top/p/java-%E5%9F%BA%E7%A1%80/","title":"java -基础"},{"content":"hugo 命令： 0 1 2 * hugo new test.md * hugo server --theme=hyde --buildDrafts * hugo server --buildDrafts github page 自定义域名 创建文件CNAME，目录（~/blog项目/static/CNAME） 内容：域名地址\neg： justkids.top\nhugo 更新记录 V1.0.0 2021.6 创建博客 主题 LoveIt V1.1.0 2021.8.05 更新主题为tack hugo 借鉴资料 github action 部署 hugo 基础命令\n","date":"2021-07-15T09:09:07+08:00","permalink":"https://justkids.top/p/hugo-%E5%9F%BA%E7%A1%80%E9%85%8D%E7%BD%AE/","title":"Hugo 基础配置"}]